
#############
#
# Maintained by Yuval Benjamini
# Adapated from Oleg Mayba, UC Berkeley
#
# This python script reads the results of a bowtie mapping
# of all possible reads from a chromosome.
# It then creates a chromosome file marking the repeats.
# This file can be an input to the GCcorrect package
#
# 
#############


import re
import sys
import os
import time
import optparse

parser = optparse.OptionParser()

parser.add_option('-r','--reference_dir',
    action="store", dest="reference_dir",
    help="Name of reference dir", default="./")
parser.add_option('-m','--mapped_dir',
    action="store", dest="mapped_dir",
    help="Name of mapped dir", default="./")
parser.add_option('-c','--chrs',
    action="store", dest="chrs",
    help="Chromosomes", default="range(1,23)+ ['X','Y','M']")
parser.add_option('-l','--readlen',
    action="store", dest="read_length",
    help="Length of reads", default="75")
parser.add_option('-p','--repeats_dir',
    action="store", dest="repeats_dir",
    help="Chromosomes", default="./")

options, args = parser.parse_args()

read_length = eval(options.read_length)
chrs = eval(options.chrs)
mapped_dir = options.mapped_dir
reference_dir = options.reference_dir
repeats_dir = options.repeats_dir


def annotate_chr_seq(chr_seq_list, repeat_list):
    # ideally, we would first check to see if the base appears in the list,
    # but in this setting we already know that each base appears either once or twice.
    # So we check to see which it is and then SHORTEN the list. This way each base doesn't
    # get compared to millions of other bases, but just to two bases in the list

    # In order not to have to re-create huge lists of numbers by subsetting,
    # I use a pointer to the current 'beginning' of the list.
    # I also do a sanity check to make sure that in fact all the reads DO map somewhere,
    # and print out the number of occasions when they do not (hopefully, 0) at the end.
    # NOTABLE EXCEPTION: READS THAT CONTAIN N'S DO NOT MAP ANYWHERE BY BOWTIE.

    error_positions=''
    current_pointer=0
    num_errors=0
    for i in xrange(len(chr_seq_list)):
        if len(re.findall('N',''.join(chr_seq_list[i:(i+read_length)])))>0:
            chr_seq_list[i]='R'
        elif repeat_list[current_pointer:(current_pointer+2)].count(i)>1:
            chr_seq_list[i]='R'
            current_pointer+=2
        elif repeat_list[current_pointer:(current_pointer+2)].count(i)==1:
            current_pointer+=1
        else:
            num_errors+=1
            error_positions+='%s\n' %(i)
    print '%s errors' %(num_errors)
    return ''.join(chr_seq_list)

def seq_from_fasta_file(fasta_file):
    fasta_seq=open(fasta_file)
    seq=''
    for line in fasta_seq:
        if line.startswith('>'):
            continue
        else:
            seq=seq+line.strip()
    fasta_seq.close()
    return seq.upper()



for chr in chrs:
    print 'chr%s' %(chr)
    # Meant to parse files generated by
    # bowtie -t -r -v 0 -k 2 bowtie_index raw_seqs_filename bowtie_outfile_name
    # -v 0 : zero mismatches
    # -k 2 : report 2 valid alignments per read
    # -r   : Input raw files
    # -t   : Time stamp
    bowtie_outfile_name = "%s/mapped_chr%s"%(mapped_dir,chr)
    chr_file=reference_dir+'chr%s.fa' %(chr)
    chr_header='>chr%s' %(chr)
    chr_seq=seq_from_fasta_file(chr_file)
    f=open(bowtie_outfile_name)
    my_repeat_list=map(lambda x: int(x.split()[0]),f)
    # Only maintains the read serial number 
    chr_seq_list=list(chr_seq)
    print 'length of chr_seq_list is %s' %(len(chr_seq_list))
    del(chr_seq)
    my_output=annotate_chr_seq(chr_seq_list,my_repeat_list)
    del(my_repeat_list)
    del(chr_seq_list)
    anno_file_name= repeats_dir+'chr%s.fa' %(chr)
    anno_file=open(anno_file_name,'w')
    anno_file.write(chr_header+'\n')
    anno_file.write(my_output)
    anno_file.close()



